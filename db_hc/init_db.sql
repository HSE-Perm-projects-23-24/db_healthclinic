
--CREATE DATABASE db_healthclinic;

CREATE SCHEMA if NOT EXISTS address;

CREATE TABLE IF NOT EXISTS address.abr
(
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    abr_name text COLLATE pg_catalog."default",
    abr_fullname text COLLATE pg_catalog."default",
    abr_insdate timestamp without time zone,
    abr_update timestamp without time zone,
    CONSTRAINT pk_abr PRIMARY KEY (id)
);

COMMENT ON TABLE address.abr IS 'Справочник аббревиатур';
COMMENT ON COLUMN address.abr.id IS 'Идентификатор';
COMMENT ON COLUMN address.abr.abr_name IS 'Аббревиатура';
COMMENT ON COLUMN address.abr.abr_fullname IS 'Расшифровка аббревиатуры';
COMMENT ON COLUMN address.abr.abr_insdate IS 'Дата загрузки записи';
COMMENT ON COLUMN address.abr.abr_update IS 'Дата обновления записи';

CREATE TABLE IF NOT EXISTS address.rgn
(
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    rgn_name text COLLATE pg_catalog."default" NOT NULL,
    rgn_insdate timestamp without time zone,
    rgn_update timestamp without time zone,
    CONSTRAINT pk_rgn PRIMARY KEY (id)
);

COMMENT ON TABLE address.rgn IS 'Справочник регионов';
COMMENT ON COLUMN address.rgn.id IS 'Идентификатор региона';
COMMENT ON COLUMN address.rgn.rgn_name IS 'Наименование региона';
COMMENT ON COLUMN address.rgn.rgn_insdate IS 'Дата загрузки записи';
COMMENT ON COLUMN address.rgn.rgn_update IS 'Дата обновления записи';

CREATE TABLE IF NOT EXISTS address.subrgn
(
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    subrgn_name text COLLATE pg_catalog."default" NOT NULL,
    fk_abr integer,
    fk_rgn integer NOT NULL,
    subrgn_insdate timestamp without time zone,
    subrgn_update timestamp without time zone,
    CONSTRAINT pk_subrgn PRIMARY KEY (id),
    CONSTRAINT fk_subrgn_rgn FOREIGN KEY (fk_rgn)
        REFERENCES address.rgn (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT fk_subrgn_abr FOREIGN KEY (fk_abr)
        REFERENCES address.abr (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
);

COMMENT ON TABLE address.subrgn IS 'Справочник районов';
COMMENT ON COLUMN address.subrgn.id IS 'Идентификатор района';
COMMENT ON COLUMN address.subrgn.subrgn_name IS 'Наименование района';
COMMENT ON COLUMN address.subrgn.fk_rgn IS 'Внешний ключ к справочнику регионов';
COMMENT ON COLUMN address.subrgn.subrgn_insdate IS 'Дата загрузки записи';
COMMENT ON COLUMN address.subrgn.subrgn_update IS 'Дата обновления записи';

CREATE TABLE IF NOT EXISTS address.town
(
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    town_name text COLLATE pg_catalog."default" NOT NULL,
    fk_subrgn integer NOT NULL,
    fk_abr integer NOT NULL,
    town_insdate timestamp without time zone,
    town_update timestamp without time zone,
    CONSTRAINT pk_town PRIMARY KEY (id),
    CONSTRAINT fk_town_subrgn FOREIGN KEY (fk_subrgn)
        REFERENCES address.subrgn (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT fk_abr_town FOREIGN KEY (fk_abr)
        REFERENCES address.town (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION    
);

COMMENT ON TABLE address.town IS 'Справочник населенных пунктов';
COMMENT ON COLUMN address.town.id IS 'Идентификатор населенного пункта';
COMMENT ON COLUMN address.town.town_name IS 'Наименование населенного пункта';
COMMENT ON COLUMN address.town.fk_subrgn IS 'Внешний ключ к справочнику районов';
COMMENT ON COLUMN address.town.fk_abr IS 'Внешний ключ к справочнику аббревиатур';
COMMENT ON COLUMN address.town.town_insdate IS 'Дата загрузки записи';
COMMENT ON COLUMN address.town.town_update IS 'Дата обновления записи';

CREATE TABLE IF NOT EXISTS address.street
(
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    street_name text COLLATE pg_catalog."default" NOT NULL,
    fk_town integer,
    fk_abr integer NOT NULL,
    street_insdate timestamp without time zone,
    street_update timestamp without time zone,
    CONSTRAINT pk_street PRIMARY KEY (id),
    CONSTRAINT fk_street_address_town FOREIGN KEY (fk_town)
        REFERENCES address.town (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT fk_street_abr FOREIGN KEY (fk_abr)
        REFERENCES address.abr (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
);


COMMENT ON TABLE address.street IS 'Справочник улиц';
COMMENT ON COLUMN address.street.id IS 'Идентификатор улицы';
COMMENT ON COLUMN address.street.street_name IS 'Наименование улицы';
COMMENT ON COLUMN address.street.fk_town IS 'Внешний ключ к справочнику населенного пункта';
COMMENT ON COLUMN address.street.fk_abr IS 'Внешний ключ к справочнику аббревиатур';
COMMENT ON COLUMN address.street.street_insdate IS 'Дата загрузки записи';
COMMENT ON COLUMN address.street.street_update IS 'Дата обновления записи';

CREATE TABLE IF NOT EXISTS address.index --Справочник индексов
(
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    fk_address_street integer, 
    index_house text COLLATE pg_catalog."default",
    index_name text COLLATE pg_catalog."default",
    index_insdate timestamp without time zone,
    index_update timestamp without time zone,
    CONSTRAINT pk_index PRIMARY KEY (id),
    CONSTRAINT fk_indexstreet_id FOREIGN KEY (fk_address_street)
        REFERENCES address.street (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
);

COMMENT ON TABLE address.index IS 'Справочник индексов с привязкой к улице и домам';
COMMENT ON COLUMN address.index.id IS 'Идентификатор';
COMMENT ON COLUMN address.index.fk_address_street IS 'Внешний ключ к таблице улиц';
COMMENT ON COLUMN address.index.index_house IS 'Диапозон домов на улице';
COMMENT ON COLUMN address.index.index_name IS 'Индекс';
COMMENT ON COLUMN address.index.index_insdate IS 'Дата загрузки записи';
COMMENT ON COLUMN address.index.index_update IS 'Дата обновления записи';

CREATE TABLE IF NOT EXISTS address.address
(
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    address_index text, --Триггером подставить
    fk_rgn integer NOT NULL,
    fk_subrgn integer,
    fk_town integer,
    fk_street integer,
    address_house text COLLATE pg_catalog."default",
    address_corpus text COLLATE pg_catalog."default",
    address_flat text COLLATE pg_catalog."default",
    address_name text COLLATE pg_catalog."default",
    address_insdate timestamp without time zone,
    address_update timestamp without time zone,
    CONSTRAINT pk_address PRIMARY KEY (id),
    CONSTRAINT fk_address_rgn FOREIGN KEY (fk_rgn)
        REFERENCES address.rgn (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT fk_address_subrgn FOREIGN KEY (fk_subrgn)
        REFERENCES address.subrgn (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT fk_address_town FOREIGN KEY (fk_town)
        REFERENCES address.town (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT fk_address_street FOREIGN KEY (fk_street)
        REFERENCES address.street (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
);

COMMENT ON TABLE address.address IS 'Справочник адресов';
COMMENT ON COLUMN address.address.address_index IS 'Индекс';
COMMENT ON COLUMN address.address.fk_rgn IS 'Внешний ключ к таблице регионов';
COMMENT ON COLUMN address.address.fk_subrgn IS 'Внешний ключ к таблице Административно-территориальное устройство';
COMMENT ON COLUMN address.address.fk_town IS 'Внешний ключ к таблице Населенных пунктов';
COMMENT ON COLUMN address.address.fk_street IS 'Внешний ключ к таблице улиц';
COMMENT ON COLUMN address.address.address_house IS 'Номер дома';
COMMENT ON COLUMN address.address.address_corpus IS 'Номер корпуса';
COMMENT ON COLUMN address.address.address_flat IS 'Номер квартиры';
COMMENT ON COLUMN address.address.address_flat IS 'Полное наименование';
COMMENT ON COLUMN address.address.address_insdate IS 'Дата загрузки записи';
COMMENT ON COLUMN address.address.address_update IS 'Дата обновления записи';


CREATE SCHEMA if NOT EXISTS userhc;

CREATE TABLE IF NOT EXISTS userhc.role
(
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    role_name text,
    CONSTRAINT pk_role  PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS userhc.user 
(
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    login_hc text NOT NULL,
    password_hc text NOT NULL,
    fk_role integer,
	user_insdate timestamp without time zone NOT NULL,
	user_update timestamp without time zone NOT NULL,
    CONSTRAINT pk_userhc_user  PRIMARY KEY (id),
    CONSTRAINT fk_userhc_role FOREIGN KEY (fk_role)
        REFERENCES userhc.role (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION

);

CREATE SCHEMA if NOT EXISTS clinic;
CREATE TABLE IF NOT EXISTS clinic.profile
(
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    profile_name text COLLATE pg_catalog."default",
    CONSTRAINT pk_profile PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS clinic.clinic
(
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    clinic_name text COLLATE pg_catalog."default" NOT NULL,
    fk_address integer NOT NULL,
    clinic_emale text COLLATE pg_catalog."default" NOT NULL,
    clinic_phone text COLLATE pg_catalog."default" NOT NULL,
    fk_profile integer NOT NULL,
    clinic_insdate timestamp without time zone,
    clinic_update timestamp without time zone,
    CONSTRAINT pk_clinic PRIMARY KEY (id),
    CONSTRAINT fk_clinic_address FOREIGN KEY (fk_address)
        REFERENCES address.address (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT fk_clinic_profile FOREIGN KEY (fk_profile)
        REFERENCES clinic.profile (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
);

CREATE SCHEMA if NOT EXISTS doctor;
CREATE TABLE IF NOT EXISTS doctor.educationtype
(
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    educationtype_name text, --Основное высшее, Переподготовка, Сертификаты
    educationtype_insdate timestamp without time zone,
    educationtype_update timestamp without time zone,
    CONSTRAINT pk_educationtype PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS clinic.specialization
(
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    specialization_name text COLLATE pg_catalog."default",
    fk_specialization_pid integer,
    CONSTRAINT pk_specialization PRIMARY KEY (id),
    CONSTRAINT fk_clinic_specialization_pid FOREIGN KEY (fk_specialization_pid)
        REFERENCES clinic.specialization (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
);

CREATE TABLE IF NOT EXISTS doctor.occupancytype
(
    id smallint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    occupancytype_name text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT pk_occupancytype_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS doctor.doctor
(
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    doctor_name text COLLATE pg_catalog."default",
    fk_clinic integer NOT NULL,
    fk_occupancytype smallint NOT NULL,
    fk_specialization integer,
    experience integer NOT NULL,
    work_start timestamp without time zone NOT NULL,
    work_finish timestamp without time zone,
    fk_user integer NOT NULL,
    doctor_insdate timestamp without time zone NOT NULL,
    doctor_update timestamp without time zone NOT NULL,
    CONSTRAINT pk_doctor PRIMARY KEY (id),
    CONSTRAINT fk_doctor_clinic FOREIGN KEY (fk_clinic)
        REFERENCES clinic.clinic (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT fk_doctor_occupancytype FOREIGN KEY (fk_occupancytype)
        REFERENCES doctor.occupancytype (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,    
    CONSTRAINT fk_doctor_specialization FOREIGN KEY (fk_specialization)
        REFERENCES clinic.specialization (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,   
    CONSTRAINT fk_userhc_user FOREIGN KEY (fk_user)
        REFERENCES userhc.user (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,     
    CONSTRAINT check_doctor_work_start CHECK  (date_part('year',age(work_start::date)) <= 70),
    CONSTRAINT check_doctor_work_finish CHECK (coalesce(work_finish, current_date) >= work_start)                                          
);

CREATE TABLE IF NOT EXISTS doctor.education
(
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    fk_doctor integer,
    fk_educationtype integer,
    fk_specialization integer,
    education_name text COLLATE pg_catalog."default",
    education_start integer,
    education_end integer,
    education_insdate timestamp without time zone,
    education_update timestamp without time zone,
    CONSTRAINT pk_education PRIMARY KEY (id),
    CONSTRAINT fk_education_educationtype FOREIGN KEY (fk_educationtype)
        REFERENCES doctor.educationtype (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT fk_education_specialization FOREIGN KEY (fk_specialization)
        REFERENCES clinic.specialization (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT fk_education_doctor FOREIGN KEY (fk_doctor)
        REFERENCES doctor.doctor (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION  
);

CREATE TABLE IF NOT EXISTS doctor.certificate
(	id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,   
    fk_doctor integer,
    certificate_name text COLLATE pg_catalog."default",
    certificate_num text,
    certificate_start timestamp without time zone,
    certificate_insdate timestamp without time zone,
    certificate_update timestamp without time zone,
    CONSTRAINT pk_hstor_certificate PRIMARY KEY (id),  
   	CONSTRAINT fk_certificate_doctor FOREIGN KEY (fk_doctor)
        REFERENCES doctor.certificate (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION  
);

CREATE TABLE IF NOT EXISTS doctor.holidaytype 
(
 id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
 holidaytype_name text COLLATE pg_catalog."default",
 CONSTRAINT pk_holidaytype PRIMARY KEY (id)
);
	
CREATE TABLE IF NOT EXISTS doctor.holiday --Отпуска и прочее, что блокирует запись
(
 id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
 fk_doctor integer,
 fk_holidaytype integer,
 holiday_start timestamp without time zone,
 holiday_finish timestamp without time zone,
 holiday_insdate timestamp without time zone NOT NULL,
 holiday_update timestamp without time zone NOT NULL,
 CONSTRAINT pk_holiday PRIMARY KEY (id),	
 CONSTRAINT fk_holiday_holidaytype FOREIGN KEY (fk_holidaytype)
       REFERENCES doctor.holidaytype (id) MATCH SIMPLE
       ON UPDATE NO ACTION
       ON DELETE NO ACTION  
);
	
CREATE TABLE IF NOT EXISTS clinic.usluga --Просто справочник всех услуг по всем профилям
(
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    fk_specialization integer,
    usluga_name text COLLATE pg_catalog."default",
    usluga_insdate timestamp without time zone NOT NULL,
    usluga_update timestamp without time zone NOT NULL,
    CONSTRAINT pk_usluga PRIMARY KEY (id),    
    CONSTRAINT fk_usluga_specialization FOREIGN KEY (fk_specialization)
        REFERENCES clinic.specialization (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION    
);

CREATE TABLE IF NOT EXISTS clinic.uslugadoctors --Cправочник услуг с привязкой к клинике, врачу, ценами
(
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,      
    fk_clinic integer, 
    fk_doctor integer,
    fk_usluga integer not null,
    prise float not null,   
    uslugadoctors_insdate timestamp without time zone NOT NULL,
    uslugadoctors_update timestamp without time zone NOT NULL,
    CONSTRAINT pk_uslugadoctors PRIMARY KEY (id),
    CONSTRAINT fk_uslugadoctors_clinic FOREIGN KEY (fk_clinic)
        REFERENCES clinic.clinic (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT fk_uslugadoctors_doctor FOREIGN KEY (fk_doctor)
        REFERENCES doctor.doctor (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,        
    CONSTRAINT fk_uslugadoctors_usluga FOREIGN KEY (fk_usluga)
        REFERENCES clinic.usluga (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION 
);

CREATE TABLE IF NOT EXISTS clinic.datework
(
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    fk_clinic integer,
    fk_uslugadoctors integer,
    datepriem date NOT NULL,
    datework_insdate timestamp without time zone NOT NULL,
    datework_update timestamp without time zone NOT NULL,
    CONSTRAINT pk_datework PRIMARY KEY (id),
    CONSTRAINT fk_datework_uslugadoctors FOREIGN KEY (fk_uslugadoctors)
        REFERENCES clinic.uslugadoctors (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT fk_datework_clinic FOREIGN KEY (fk_clinic)
        REFERENCES clinic.clinic (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION 
);

CREATE TABLE IF NOT EXISTS clinic.timework
(
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    fk_datework bigint,
    timework time without time zone NOT NULL,
    timework_insdate timestamp without time zone NOT NULL,
    timework_update timestamp without time zone NOT NULL,    
    CONSTRAINT pk_timework PRIMARY KEY(id),
    CONSTRAINT fk_timework_clinic FOREIGN KEY (fk_datework)
        REFERENCES clinic.datework (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
);

CREATE SCHEMA if NOT EXISTS patient;

CREATE TABLE IF NOT EXISTS patient.insurance
(
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    insurance_name text COLLATE pg_catalog."default",
    fk_address integer,
    insurance_phone text COLLATE pg_catalog."default",
    insurance_emaile text COLLATE pg_catalog."default",
    insurance_insdate timestamp without time zone,
    insurance_update timestamp without time zone,
    CONSTRAINT pk_insurance PRIMARY KEY (id),
    CONSTRAINT fk_insurance_address FOREIGN KEY (fk_address)
        REFERENCES address.address (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
);

CREATE TABLE IF NOT EXISTS patient.patient
(
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    patient_surname text COLLATE pg_catalog."default" NOT NULL,
    patient_firstname text COLLATE pg_catalog."default" NOT NULL,
    patient_secname text COLLATE pg_catalog."default",
    patient_birthday timestamp without time zone NOT NULL,
    fk_address_reg integer,
    fk_address_fact integer,
    card_num text COLLATE pg_catalog."default",
    card_begdate timestamp NOT NULL,
    card_enddate timestamp,
    sex_id smallint NOT NULL,
    patient_attribute json,
    fk_user integer NOT NULL,
    patient_insdate timestamp without time zone NOT NULL,
    patient_update timestamp without time zone NOT NULL,
    CONSTRAINT pk_patient PRIMARY KEY (id),    
    CONSTRAINT fk_patient_adress_reg FOREIGN KEY (fk_address_reg)
        REFERENCES address.address (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT fk_patient_adress_fact FOREIGN KEY (fk_address_fact)
        REFERENCES address.address (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
     CONSTRAINT fk_patient_user FOREIGN KEY (fk_user)
        REFERENCES userhc.user (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,   
    CONSTRAINT check_patient_birthday CHECK (patient_birthday > '1920-01-01 00:00:00'::timestamp without time zone),
    CONSTRAINT check_card_enddate CHECK (card_enddate > card_begdate or card_enddate is null)
);

CREATE TABLE IF NOT EXISTS patient.polis
(
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    fk_patient integer,
    polis_num text COLLATE pg_catalog."default",
    polis_start timestamp without time zone,
    polis_end timestamp without time zone,
    fk_insurance integer,
    polis_insdate timestamp without time zone,
    polis_update timestamp without time zone,
    CONSTRAINT pk_polis PRIMARY KEY (id),
    CONSTRAINT fk_patient_insurance FOREIGN KEY (fk_insurance)
        REFERENCES patient.insurance (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
     CONSTRAINT fk_polis_patient FOREIGN KEY (fk_patient)
        REFERENCES patient.patient (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION  
);

CREATE VIEW clinic.v_recording AS
select 
	clinic.datework.fk_clinic,
	uslugadoctors.fk_doctor,
	clinic.datework.fk_uslugadoctors,
	clinic.datework.id as fk_datework,
	clinic.datework.datepriem,
	clinic.timework.timework as timework_time
from clinic.datework
join clinic.timework on clinic.datework.id= clinic.timework.fk_datework
join clinic.uslugadoctors uslugadoctors on uslugadoctors.id =clinic.datework.fk_uslugadoctors
and uslugadoctors.fk_clinic = clinic.datework.fk_clinic;


CREATE TABLE IF NOT EXISTS clinic.recording
(
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    fk_clinic integer,
    fk_doctor integer,
    fk_uslugadoctors integer,      
    fk_patient bigint,
    datework_date date NOT NULL,
    timework_time time without time zone,
    confirm boolean, --Подтверждение записи при телефонном звонке для регистратора
    recording_factdate date, --Дата посещения
    recording_facttime time without time zone,--Дата посещения
    get_recording boolean, --Маркер Пришел или нет
    recording_insdate timestamp without time zone NOT NULL,
    recording_update timestamp without time zone NOT NULL,    
    CONSTRAINT pk_recording PRIMARY KEY (id),
    CONSTRAINT fk_recording_clinic FOREIGN KEY (fk_clinic)
        REFERENCES clinic.clinic (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
	CONSTRAINT fk_recording_doctor FOREIGN KEY (fk_doctor)
        REFERENCES doctor.doctor (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
	CONSTRAINT fk_recording_uslugadoctors FOREIGN KEY (fk_uslugadoctors)
        REFERENCES clinic.uslugadoctors (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT fk_recording_patient FOREIGN KEY (fk_patient)
        REFERENCES patient.patient (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT check_recording_factdate CHECK (coalesce(recording_factdate,current_date) >= (datework_date+timework_time)::timestamp)
);


CREATE SCHEMA if NOT EXISTS hstor;
	
CREATE TABLE IF NOT EXISTS hstor.doctor
(
    fk_doctor integer,
    doctor_name text COLLATE pg_catalog."default",
    fk_clinic integer NOT NULL,
    fk_occupancytype smallint NOT NULL,
    fk_specialization integer NOT NULL,
    experience integer NOT NULL,
    work_start timestamp without time zone NOT NULL,
    work_finish timestamp without time zone NOT NULL,
    fk_user integer NOT NULL,
    doctor_insdate timestamp without time zone NOT NULL,
    doctor_update timestamp without time zone NOT NULL,
    doctor_typemodify text COLLATE pg_catalog."default",
    doctor_datemodify timestamp without time zone,
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    CONSTRAINT pk_hstor_doctor PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS hstor.patient
(
    fk_patient integer,
    patient_surname text COLLATE pg_catalog."default" NOT NULL,
    patient_firstname text COLLATE pg_catalog."default" NOT NULL,
    patient_secname text COLLATE pg_catalog."default",
    patient_birthday timestamp without time zone NOT NULL,
    fk_address_reg integer,
    fk_address_fact integer,
    card_num text COLLATE pg_catalog."default",
    card_begdate timestamp NOT NULL,
    card_enddate timestamp NOT NULL,
    sex_id smallint NOT NULL,
    patient_attribute json,
    fk_user integer NOT NULL,
    patient_insdate timestamp without time zone NOT NULL,
    patient_update timestamp without time zone NOT NULL,
    patient_typemodify text COLLATE pg_catalog."default",
    patient_datemodify timestamp without time zone,
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    CONSTRAINT pk_hstor_patient PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS hstor.usluga 
(
    fk_usluga integer,
    fk_specialization integer,
    usluga_name text COLLATE pg_catalog."default",
    usluga_insdate timestamp without time zone NOT NULL,
    dusluga_update timestamp without time zone NOT NULL,
    usluga_typemodify text COLLATE pg_catalog."default",
    usluga_datemodify timestamp without time zone,
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    CONSTRAINT pk_hstor_usluga PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS hstor.uslugadoctors --Cправочник услуг с привязкой к клинике, врачу, ценами
(
    fk_uslugadoctors integer,
    fk_clinic integer not null, 
    fk_doctor integer,
    fk_usluga integer not null,
    prise float not null,  
    uslugadoctors_insdate timestamp without time zone NOT NULL,
    uslugadoctors_update timestamp without time zone NOT NULL,
    uslugadoctors_typemodify text COLLATE pg_catalog."default",
    uslugadoctors_datemodify timestamp without time zone,
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    CONSTRAINT pk_hstor_uslugadoctors PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS hstor.education
(
   	fk_education integer,
	fk_doctor integer,
    fk_educationtype integer,
    fk_specialization integer,
    education_name text COLLATE pg_catalog."default",
    education_start integer,
    education_end integer,
    education_insdate timestamp without time zone,
    education_update timestamp without time zone,
	education_typemodify text COLLATE pg_catalog."default",
    education_datemodify timestamp without time zone,	
	id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    CONSTRAINT pk_hstor_education PRIMARY KEY (id)    
);


CREATE TABLE IF NOT EXISTS hstor.certificate
(
    fk_certificate integer,
    fk_doctor integer,
    certificate_name text COLLATE pg_catalog."default",
    certificate_num INTEGER,
    certificate_start timestamp without time zone,
    certificate_insdate timestamp without time zone,
    certificate_update timestamp without time zone,
    certificate_typemodify text COLLATE pg_catalog."default",
    certificate_datemodify timestamp without time zone,
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    CONSTRAINT pk_hstor_certificate PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS hstor.holiday
(
	fk_holiday integer,
	fk_doctor integer,
    fk_holidaytype integer,
	holiday_start timestamp without time zone,
	holiday_finish timestamp without time zone,	
	holiday_insdate timestamp without time zone NOT NULL,
	holiday_update timestamp without time zone NOT NULL,
    holiday_typemodify text COLLATE pg_catalog."default",
    holiday_datemodify timestamp without time zone,
    id integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    CONSTRAINT pk_hstor_holiday PRIMARY KEY (id)
);

CREATE OR REPLACE FUNCTION hstor.periodic_table()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF SECURITY DEFINER
AS $BODY$
DECLARE
	query_sql text;
	arrTable text[]:= ARRAY [
    'doctor.doctor',
    'clinic.usluga',
    'clinic.uslugadoctors',
    'patient.patient',
    'doctor.education',
    'doctor.certificate',
	'doctor.holiday'
    ];

BEGIN
	
	IF TG_TABLE_SCHEMA||'.'|| TG_TABLE_NAME = ANY(arrTable) 
		THEN query_sql='INSERT INTO hstor.'|| TG_TABLE_NAME||' SELECT ($1).*,$2,now()';
	END IF;
	
	IF (TG_OP = 'DELETE' or TG_OP = 'UPDATE')
	THEN
		EXECUTE query_sql using OLD,TG_OP;
		RETURN OLD;	
	END IF;

END;
$BODY$;

ALTER FUNCTION hstor.periodic_table()
    OWNER TO postgres;

CREATE OR REPLACE TRIGGER tr_periodic
    AFTER DELETE OR UPDATE 
    ON doctor.doctor
    FOR EACH ROW
    EXECUTE FUNCTION hstor.periodic_table();

CREATE OR REPLACE TRIGGER tr_periodic
    AFTER DELETE OR UPDATE 
    ON patient.patient
    FOR EACH ROW
    EXECUTE FUNCTION hstor.periodic_table();
	
CREATE OR REPLACE TRIGGER tr_periodic
    AFTER DELETE OR UPDATE 
    ON clinic.uslugadoctors
    FOR EACH ROW
    EXECUTE FUNCTION hstor.periodic_table();
	
CREATE OR REPLACE TRIGGER tr_periodic
    AFTER DELETE OR UPDATE 
    ON clinic.usluga
    FOR EACH ROW
    EXECUTE FUNCTION hstor.periodic_table();
	
--ТРИГГЕР на адреса и индекс 
CREATE OR REPLACE FUNCTION address.add_address_index_name()
    RETURNS trigger
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE NOT LEAKPROOF SECURITY DEFINER

AS $BODY$
BEGIN

	update address.address
	set address_index = (select idx.index_name
				from address.index idx 
			   	where true
			    and idx.fk_address_street =new.fk_street
				and ('{'||new.address_house||'}')::text[] && ('{'||idx.index_house||'}')::text[]
			)	
	where true
	and fk_rgn = new.fk_rgn
	and fk_subrgn = new.fk_subrgn
	and fk_town = new.fk_town
	and fk_street = new.fk_street
	and address_house = new.address_house
	and (address_corpus = new.address_corpus or new.address_corpus is null)
	and (address_flat = new.address_flat or new.address_flat is null);
	RETURN NEW;	
	
END;
$BODY$;

ALTER FUNCTION address.add_address_index_name()
    OWNER TO postgres;

CREATE OR REPLACE TRIGGER tr_address_index
    AFTER Insert
    ON address.address
    FOR EACH ROW
    EXECUTE FUNCTION address.add_address_index_name()